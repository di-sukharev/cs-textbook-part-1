/*
    АЛУ (Арифметико-логическое устройство)

    Вычисляет одну из функций:
    x+y, x-y, y-x, 0, 1, -1, x, y, -x, -y, !x, !y,
    x+1, y+1, x-1, y-1, x&y, x|y on two 16-bit inputs, 
    в зависимости от шести контрол инпутов: zx, nx, zy, ny, f, no.
    
    В дополнение АЛУ имеет два аутпут-флага:
    если основной аутпут АЛУ == 0, флаг zr устанавливается в 1; в обратном случае zr устанавливается в 0;
    если основной аутпут АЛУ < 0, флаг ng устанавливается в 1; в обратном случае ng устанавливается в 0.
*/

/* 
    Таблица функций:
    | zx | nx | zy | ny | f | no | out |
    |----|----|----|----|---|----|-----|
    |  1 |  0 |  1 |  0 | 1 |  0 | 0   |
    |  1 |  1 |  1 |  1 | 1 |  1 | 1   |
    |  1 |  1 |  1 |  0 | 1 |  0 | -1  |
    |  0 |  0 |  1 |  1 | 0 |  0 | x   |
    |  1 |  1 |  0 |  0 | 0 |  0 | y   |
    |  0 |  0 |  1 |  1 | 0 |  1 | !x  |
    |  1 |  1 |  0 |  0 | 0 |  1 | !y  |
    |  0 |  0 |  1 |  1 | 1 |  1 | -x  |
    |  1 |  1 |  0 |  0 | 1 |  1 | -y  |
    |  0 |  1 |  1 |  1 | 1 |  1 | x+1 |
    |  1 |  1 |  0 |  1 | 1 |  1 | y+1 |
    |  0 |  0 |  1 |  1 | 1 |  0 | x-1 |
    |  1 |  1 |  0 |  0 | 1 |  0 | y-1 |
    |  0 |  0 |  0 |  0 | 1 |  0 | x+y |
    |  0 |  1 |  0 |  0 | 1 |  1 | x-y |
    |  0 |  0 |  0 |  1 | 1 |  1 | y-x |
    |  0 |  0 |  0 |  0 | 0 |  0 | x&y |
    |  0 |  1 |  0 |  1 | 0 |  1 | x|y |
*/

/*
    Реализация: АЛУ принимает два 16-битных инпута
    и чтобы вычислить аутпут, манипулирует ими вот так:
    если (zx == 1) установить x=0 (16-битная константа)
    если (nx == 1) установить x=!x (побитовая операция not)
    если (zy == 1) установить y=0 (16-битная константа)
    если (ny == 1) установить y=!y (побитовая операция not)
    если (f == 1)  установить out=x+y (сложение в дополнительном коде)
    если (f == 0)  установить out=x&y (побитовая операция and)
    если (no == 1) установить out=!out (побитовая операция not)
    если (out == 0) установить zr=1
    если (out < 0) установить ng=1
*/

CHIP ALU {
    IN
        x[16], y[16],  // 16-битные инпуты
        zx, // флаг: установить инпут x=0
        nx, // флаг: инвертировать инпут x
        zy, // флаг: установить инпут y=0
        ny, // флаг: инвертировать инпут y
        f,  // флаг: вычислить out=x+y если (f == 1) ИЛИ x&y если (f == 0)
        no; // флаг: инвертировать аутпут out

    OUT
        out[16], // 16-битный аутпут
        zr, // флаг: zr=1 если (out == 0) ИЛИ zr=0
        ng; // флаг: ng=1 если (out < 0) ИЛИ ng=0

    PARTS:
        // шаг 1. если (zx == 1) -> перезаписать инпут x в 000…000
        // шаг 2. если (nx == 1) -> инвертировать инпут x

        // шаг 3. если (zy == 1) -> перезаписать инпут y в 000…000
        // шаг 4. если (ny == 1) -> инвертировать инпут y

        // шаг 5. вычисляем x+y и x&y отдельно
        // шаг 6. если (f == 1) -> out=x+y ИЛИ x&y

        // шаг 7. если (no == 1) -> инвертируем аутпут out
        // шаг 8. если (out < 0) -> устанавливаем аутпут-флаг ng=1

        // шаг 9. если (out == 0) -> устанавливаем аутпут-флаг zr=1
}

/*
    Чтобы передать в инпут единицу — используйте ключевое слово `true`.
    Чтобы передать ноль — используйте `false`.

    Пример, передаем lsb=1:
    Not16(in[0]=true, out=output);

    В примере выше мы передали единицу в lsb, остальные биты in[1..15] симулятор заполнил нулями автоматически.

    Мы также можем передать ноль в lsb и единицу в msb:
    Not16(in[0]=false, in[15]=true, out=output);

    Можем заполнить все биты единицами:
    Not16(in=true, out=output);

    lsb — это least significant bit (наименее значимый бит, самый правый).
    msb — это most significant bit (наиболее значимый бит, самый левый).

    x001010y — здесь x это msb, а y это lsb.
*/